/* $Id: model_in_smf.c,v 1.12 2004/04/30 07:50:22 aspert Exp $ */


/*
 *
 *  Copyright (C) 2001-2004 EPFL (Swiss Federal Institute of Technology,
 *  Lausanne) This program is free software; you can redistribute it
 *  and/or modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2 of
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 *  USA.
 *
 *  In addition, as a special exception, EPFL gives permission to link
 *  the code of this program with the Qt non-commercial edition library
 *  (or with modified versions of Qt non-commercial edition that use the
 *  same license as Qt non-commercial edition), and distribute linked
 *  combinations including the two.  You must obey the GNU General
 *  Public License in all respects for all of the code used other than
 *  Qt non-commercial edition.  If you modify this file, you may extend
 *  this exception to your version of the file, but you are not
 *  obligated to do so.  If you do not wish to do so, delete this
 *  exception statement from your version.
 *
 *  Authors : Nicolas Aspert, Diego Santa-Cruz and Davy Jacquet
 *
 *  Web site : http://mesh.epfl.ch
 *
 *  Reference :
 *   "MESH : Measuring Errors between Surfaces using the Hausdorff distance"
 *   in Proceedings of IEEE Intl. Conf. on Multimedia and Expo (ICME) 2002, 
 *   vol. I, pp. 705-708, available on http://mesh.epfl.ch
 *
 */




#include <model_in.h>
#include <block_list.h>
#ifdef DEBUG
# include <debug_print.h>
#endif

/* Reads a _triangular_ mesh from a SMF file (used by M. Garland's QSlim).
 * Only the vertices and faces are read. All other possible fields in
 * SMF files (i.e. color, bindings, begin/end, transform ...) are
 * skipped silently. However, this code should be sufficient to read
 * SMF files generated by QSlim ...
 * It returns the number of meshes read (i.e. 1) if successful, and a 
 * negative code if it failed. */
int read_smf_tmesh(struct model **tmesh_ref, struct file_data *data) {
  int  c;
  struct model *tmesh;
  vertex_t bbmin, bbmax;
  int max_vidx=-1;
  int nvtcs=0;
  int nfaces=0;
  int f0, f1, f2;
  float x, y, z;
  int rcode = 1;
  struct block_list *head_verts, *cur_vert;
  struct block_list *head_faces, *cur_face;
  
  head_verts = (struct block_list*)malloc(sizeof(struct block_list));
  head_faces = (struct block_list*)malloc(sizeof(struct block_list));
  
  cur_vert = head_verts;
  cur_face = head_faces;

  bbmin.x = bbmin.y = bbmin.z = FLT_MAX;
  bbmax.x = bbmax.y = bbmax.z = -FLT_MAX;
  tmesh = (struct model*)calloc(1, sizeof(struct model));

  rcode = init_block_list(head_verts, sizeof(vertex_t));
  if(rcode < 0) 
    return rcode;

  rcode = init_block_list(head_faces, sizeof(face_t));
  if(rcode < 0)
    return rcode;

  do {
    c = skip_ws_comm(data);
    if (c == EOF) break; /* maybe ok if we have reached the end of
                          *  file */
    
    c = getc(data); /* get 1st char of the current line */
    
    switch (c) {
    case 'v': /* vertex line found */
      if (cur_vert->elem_filled == cur_vert->nelem) { 
	/* Reallocate storage if needed */
	cur_vert = get_next_block(cur_vert);
	if (cur_vert == NULL) {
	  rcode = MESH_NO_MEM;
          break;
        }
      }
      if (float_scanf(data, &x) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (float_scanf(data, &y) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (float_scanf(data, &z) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }

#ifdef DEBUG
      DEBUG_PRINT("%f %f %f\n", x, y, z);
#endif
      BLOCK_LIST_TAIL(cur_vert, vertex_t).x = x;
      BLOCK_LIST_TAIL(cur_vert, vertex_t).y = y;
      BLOCK_LIST_TAIL_INCR(cur_vert, vertex_t).z = z;
      nvtcs++;

      if (x < bbmin.x) bbmin.x = x;
      if (x > bbmax.x) bbmax.x = x;
      if (y < bbmin.y) bbmin.y = y;
      if (y > bbmax.y) bbmax.y = y;
      if (z < bbmin.z) bbmin.z = z;
      if (z > bbmax.z) bbmax.z = z;

      break; /* end for 'v' */

    case 'f':/* face line found */
      if (cur_face->elem_filled == cur_face->nelem) { 
	/* Reallocate storage if needed */
	cur_face = get_next_block(cur_face);
        if (cur_face == NULL) {
          rcode = MESH_NO_MEM;
          break;
        }
      }

      if (int_scanf(data, &f0) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (int_scanf(data, &f1) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
      if (int_scanf(data, &f2) != 1) {
        rcode = MESH_CORRUPTED;
        break;
      }
#ifdef DEBUG
      DEBUG_PRINT("%d %d %d\n", f0, f1, f2);
#endif
      /* Do not forget that SMF vertex indices start at 1 !! */
      BLOCK_LIST_TAIL(cur_face, face_t).f0 = --f0;
      BLOCK_LIST_TAIL(cur_face, face_t).f1 = --f1;
      BLOCK_LIST_TAIL_INCR(cur_face, face_t).f2 = --f2;
      nfaces++;
      if (f0 > max_vidx) max_vidx = f0;
      if (f1 > max_vidx) max_vidx = f1;
      if (f2 > max_vidx) max_vidx = f2;

      if (f0 < 0 || f1 < 0 || f2 < 0)
        rcode = MESH_CORRUPTED;

      break; /* end for 'f' */

    default: /* only the faces & vertices are read. We choose to
              *  ignore every other field from the SMF spec. */

      do { /* neither a face, nor a vertex => skip the whole line */
        c = getc(data);
      } while (c != EOF && c != '\n' && c != '\r');

      break;
    }

  } while(c != EOF  && rcode >= 0);

  if (max_vidx >= nvtcs)
    rcode = MESH_CORRUPTED;

  if (nvtcs == 0) {
    memset(&bbmin, 0, sizeof(bbmin));
    memset(&bbmax, 0, sizeof(bbmax));
  }

  if (rcode >= 0) {
    tmesh->bBox[0] = bbmin;
    tmesh->bBox[1] = bbmax;
    tmesh->num_vert = nvtcs;
    tmesh->num_faces = nfaces;
    tmesh->vertices = malloc(nvtcs*sizeof(vertex_t));
    tmesh->faces = malloc(nfaces*sizeof(face_t));
    rcode = gather_block_list(head_verts, tmesh->vertices, 
                              nvtcs*sizeof(vertex_t));
    rcode = gather_block_list(head_faces, tmesh->faces, 
                              nfaces*sizeof(face_t));
    free_block_list(&head_verts);
    free_block_list(&head_faces);
    if (rcode >= 0) {
      *tmesh_ref = tmesh;
      rcode = 1;
    }
    else 
      __free_raw_model(tmesh);
  } else 
    __free_raw_model(tmesh);
  
  return rcode;
}
